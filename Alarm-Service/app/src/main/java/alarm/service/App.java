/*
 * This source file was generated by the Gradle 'init' task
 */
package alarm.service;

import main.java.alarm.model.AlarmEvent;
import main.java.alarm.model.SensorReading;
import main.java.alarm.serde.JsonSerde;
import main.java.alarm.time.ReadingTimestampExtractor;
import main.java.alarm.transform.AlarmEvaluator;
import main.java.alarm.util.ThresholdLoader;
import main.java.alarm.model.Threshold;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.*;
import org.apache.kafka.streams.kstream.Consumed;
import org.apache.kafka.streams.kstream.Produced;
import org.apache.kafka.streams.state.Stores;

import java.util.Map;
import java.util.Properties;

public class App {
    private static String getEnvOrDefault(String key, String def) {
    String v = System.getenv(key);
    return (v == null || v.isBlank()) ? def : v;
}

public static void main(String[] args) {
    // Defaults aus application.properties und ENV
    String bootstrap = getEnvOrDefault("BOOTSTRAP_SERVERS", System.getProperty("bootstrap.servers", "kafka:9092"));
    String appId     = getEnvOrDefault("APPLICATION_ID", System.getProperty("application.id", "storasense-alarmservice"));
    String input     = getEnvOrDefault("INPUT_TOPIC", System.getProperty("input.topic", "iot-sensordata"));
    String output    = getEnvOrDefault("OUTPUT_TOPIC", System.getProperty("output.topic", "alarms"));
    long windowSec   = Long.parseLong(getEnvOrDefault("WINDOW_SECONDS", System.getProperty("window.seconds", "30")));
    String thrFile   = getEnvOrDefault("THRESHOLDS_FILE", System.getProperty("thresholds.file", "/app/config/thresholds.json"));
    double defMin    = Double.parseDouble(getEnvOrDefault("DEFAULT_MIN", System.getProperty("default.min", "0.0")));
    double defMax    = Double.parseDouble(getEnvOrDefault("DEFAULT_MAX", System.getProperty("default.max", "100.0")));

    Map<String, Threshold> thresholds = ThresholdLoader.load(thrFile);

    Properties props = new Properties();
    props.put(StreamsConfig.APPLICATION_ID_CONFIG, appId);
    props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrap);
    props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
    // Optional: Exactly-Once
    // props.put(StreamsConfig.PROCESSING_GUARANTEE_CONFIG, StreamsConfig.EXACTLY_ONCE_V2);
    props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, "1");

    StreamsBuilder builder = new StreamsBuilder();

    var readingSerde = new JsonSerde<>(SensorReading.class);
    var alarmSerde   = new JsonSerde<>(AlarmEvent.class);

    // StateStore
    var storeName = "sensor-state-store";
    var storeBuilder = Stores.keyValueStoreBuilder(
            Stores.persistentKeyValueStore(storeName),
            Serdes.String(),
            new JsonSerde<>(AlarmEvaluator.SensorState.class)
    );
    builder.addStateStore(storeBuilder);

    // Input-Stream (Eventzeit)
    var readings = builder.stream(input,
            Consumed.with(Serdes.String(), readingSerde)
                    .withTimestampExtractor(new ReadingTimestampExtractor()));

    // Transform + State
    var alarms = readings.transformValues(
            () -> new AlarmEvaluator(storeName, thresholds, defMin, defMax, windowSec * 1000L),
            storeName
    ).filter((k, v) -> v != null);

    // Output
    alarms.to(output, Produced.with(Serdes.String(), alarmSerde));

    Topology topology = builder.build();
    KafkaStreams streams = new KafkaStreams(topology, props);

    Runtime.getRuntime().addShutdownHook(new Thread(streams::close));
    streams.start();
}

}
