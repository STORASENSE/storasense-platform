<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://github.com/STORASENSE/storasense-platform/content/arc/data_eva/ rel=canonical><link rel=icon href=../../../images/icon01.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.15"><title>Datendomäne - STORASENSE</title><link rel=stylesheet href=../../../assets/stylesheets/main.342714a4.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../styles/extra.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=black data-md-color-accent=blue> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#datendomane class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=STORASENSE class="md-header__button md-logo" aria-label=STORASENSE data-md-component=logo> <img src=../../../images/icon01.png alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> STORASENSE </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Datendomäne </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/STORASENSE/storasense-platform title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg> </div> <div class=md-source__repository> STORASENSE/storasense-platform </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=STORASENSE class="md-nav__button md-logo" aria-label=STORASENSE data-md-component=logo> <img src=../../../images/icon01.png alt=logo> </a> STORASENSE </label> <div class=md-nav__source> <a href=https://github.com/STORASENSE/storasense-platform title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg> </div> <div class=md-source__repository> STORASENSE/storasense-platform </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> <span class=md-ellipsis> About </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> About </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../intro_goals.md class=md-nav__link> <span class=md-ellipsis> Vision </span> </a> </li> <li class=md-nav__item> <a href=../../../mvp.md class=md-nav__link> <span class=md-ellipsis> MVP </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../../techstack.md class=md-nav__link> <span class=md-ellipsis> Technologies </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> Architecture </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Architecture </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../arc.md class=md-nav__link> <span class=md-ellipsis> Architecture Overview </span> </a> </li> <li class=md-nav__item> <a href=../../../data_eva.md class=md-nav__link> <span class=md-ellipsis> Data Domain </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex=0> <span class=md-ellipsis> Components </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=false> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> Components </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../arduino.md class=md-nav__link> <span class=md-ellipsis> Storasense-Sensoric (Arduino) </span> </a> </li> <li class=md-nav__item> <a href=../../../backend.md class=md-nav__link> <span class=md-ellipsis> Backend </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#datenmodellierung-konzeptuell class=md-nav__link> <span class=md-ellipsis> Datenmodellierung (Konzeptuell) </span> </a> </li> <li class=md-nav__item> <a href=#datenvolumen class=md-nav__link> <span class=md-ellipsis> Datenvolumen </span> </a> </li> <li class=md-nav__item> <a href=#nichtfunktionale-anforderungen-datendomane class=md-nav__link> <span class=md-ellipsis> Nichtfunktionale Anforderungen &lt;=&gt; Datendomäne </span> </a> </li> <li class=md-nav__item> <a href=#datenbankauswahl-kriterien class=md-nav__link> <span class=md-ellipsis> Datenbankauswahl - Kriterien </span> </a> </li> <li class=md-nav__item> <a href=#sql-vs-nosql class=md-nav__link> <span class=md-ellipsis> SQL vs NoSQL </span> </a> </li> <li class=md-nav__item> <a href=#datenbanktechnologie-postgresql-mit-timescaledb class=md-nav__link> <span class=md-ellipsis> Datenbanktechnologie - PostgreSQl mit TimescaleDB </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=datendomane>Datendomäne<a class=headerlink href=#datendomane title="Permanent link">&para;</a></h1> <h2 id=datenmodellierung-konzeptuell>Datenmodellierung (Konzeptuell)<a class=headerlink href=#datenmodellierung-konzeptuell title="Permanent link">&para;</a></h2> <p>Vor der Auswahl einer spezifischen Datenbanktechnologie wird das fachliche Datenmodell definiert, das alle für das System STORASENSE relevanten Informationen und deren Beziehungen zueinander abbildet. Diese ergeben sich aus den definierten <a href=content/about/mvp.md>Anforderungen</a>. <br> Insgesamt basiert das Modell auf <strong>fünf Entitäten</strong>:</p> <ul> <li><strong>User</strong>: Stellt eine Person dar, die mit dem System interagiert. Ein Benutzer beinhaltet folgende Attribute:</li> <li><em>ID</em>: Eine eindeutige ID des Benutzers</li> <li><em>Username</em>: Ein eindeutiger Benutzername</li> <li><em>Passwort</em>: Ein Passwort (mit Hashing)</li> <li><em>Rolle</em>: Eine Rolle, die den Zugriff auf ein Lagerort einschränkt</li> <li><em>Beschreibung</em>: Eine optionale Beschreibung des Benutzers</li> <li><em>Lagerorte</em>: Referenzen auf zugegriffene Lagerorte <br> <br></li> <li><strong>Storage</strong>: Repräsentiert einen physischen Ort (z.B. "Weinkeller A", "Lagerhalle B"), der überwacht wird. Jeder Lagerort besitzt eindeutige Attribute wie eine ID und einen Namen. Ein Lagerort beinhaltet folgende Attribute:</li> <li><em>ID</em>: Eine eindeutige ID des Lagerorts</li> <li><em>Name</em>: Ein eindeutiger Name des Lagerorts (z.B. "Weinkeller A")</li> <li><em>Beschreibung</em>: Eine optionale Beschreibung des Lagerorts</li> <li><em>Nutzer</em>: Referenzen auf Nutzer, die auf den Lagerort Zugriff haben <br> <br></li> <li><strong>Sensor</strong>: Stellt einen physischen Sensor dar, der Messwerte erfasst. Ein Sensor beinhaltet folgende Attribute:</li> <li><em>ID</em>: Eine eindeutige ID des Sensors</li> <li><em>Typ</em>: Der Typ des Sensors (z.B. Temperatur, Luftfeuchtigkeit)</li> <li><em>Min &amp; Max</em>: Grenzwerte für den Sensor</li> <li><em>Lagerort</em>: Eine Referenz auf den Lagerort, an dem sich der Sensor befindet <br> <br></li> <li><strong>Measurement</strong>: Repräsentiert eine einzelne, zu einem exakten Zeitpunkt erfasste Messung (z.B. Temperatur, Luftfeuchtigkeit). Ein Messwert beinhaltet folgende Attribute:</li> <li><em>ID</em>: Eine eindeutige ID der Messung</li> <li><em>Erstellungszeit</em>: Der genaue Zeitpunkt der Messung</li> <li><em>Wert</em>: Der gemessene Wert</li> <li><em>Einheit</em>: Die Einheit des Messwertes (z.B. Temperatur in °C, Luftfeuchtigkeit in %)</li> <li><em>Sensor</em>: Eine Referenz auf den Sensor, der die Messung entnommen hat <br> <br></li> <li><strong>Alert</strong>: Repräsentiert einen Alarm, der ausgelöst wird, wenn ein Messwert außerhalb eines definierten Schwellenwerts liegt. Ein Alarm beinhaltet folgende Attribute:</li> <li><em>ID</em>: Eine eindeutige ID des Alarms</li> <li><em>Beschreibung</em>: Eine beschreibung des Alarms (z.B. "Temperatur zu hoch")</li> <li><em>Schweregrad</em>: Der Schweregrad des Alarms (z.B. "hoch", "mittel", "niedrig")</li> <li><em>Messung</em>: Eine Referenz auf die Messung, die den Alarm ausgelöst hat <br></li> </ul> <h2 id=datenvolumen>Datenvolumen<a class=headerlink href=#datenvolumen title="Permanent link">&para;</a></h2> <p>Das erwartete Datenvolumen ist moderat, da das System in erster Linie Echtzeitdaten von Sensoren erfasst und speichert.</p> <h3 id=datenmenge>Datenmenge<a class=headerlink href=#datenmenge title="Permanent link">&para;</a></h3> <h4 id=measurement>Measurement:<a class=headerlink href=#measurement title="Permanent link">&para;</a></h4> <p>Wie eingangs im <a href=content/about/mvp.md#funktionale-anforderungen>Projektüberblick</a> beschrieben, besteht die Sensorik des Systems aus vier Sensoren die täglich für 2.5 Monate alle 30 Sekunden Messwerte erfassen. Folgende Rechnung verdeutlicht die erwartete Datenmenge:</p> <ul> <li>Anzahl der Sensoren: 4</li> <li>Jeder Sensor sendet alle 30 Sekunden einen Messwert.</li> <li>Das ergibt:</li> <li>Messungen pro Stunde pro Sensor: (60/30) x 60 = 120</li> <li>Messungen pro Tag pro Sensor: 120 x 24 = 2.880</li> <li>Messungen pro Tag gesamt (4 Sensoren): 2.880 x 4 = 11.520</li> <li>Messungen für 2,5 Monate (ca. 75 Tage): 11.520 x 75 = <strong>864.000 Messpunkte</strong></li> </ul> <p>Insgesamt werden also ca. <strong>864.000 Messpunkte</strong> erwartet, die in der Datenbank gespeichert werden müssen.</p> <h4 id=weitere-entitaten>Weitere Entitäten:<a class=headerlink href=#weitere-entitaten title="Permanent link">&para;</a></h4> <p>Die weiteren Entitäten haben eine deutlich geringere Anzahl an Instanzen:</p> <ul> <li>Wie bereits im <a href=content/about/mvp.md#funktionale-anforderungen>Projektüberblick</a> beschrieben unterstützt das System bis zu 500 Benutzer und 50 Lagerorte.</li> <li>Weiter sind 2 Rollen vorgesehen, die den Benutzern zugeordnet werden können.</li> <li>Die letzten 500 Alarme eines Lagerorts werden ebenfalls gespeichert. So ergibt sich eine maximale Anzahl von 25.000 Alarm-Einträgen (500 Alarme x 50 Lagerorte).</li> </ul> <p>Insgesamt sind die weiteren Entitäten also zu vernachlässigen, da sie nur eine geringe Anzahl an Instanzen haben. <br> <strong>Außerdem gilt es zu beachten, dass der Großteil der Daten der weiteren Entitäten sich in der Regel nicht ständig ändern, sondern einmal angelegt werden und ggf. selten aktualisiert werden.</strong></p> <h3 id=datengroe>Datengröße<a class=headerlink href=#datengroe title="Permanent link">&para;</a></h3> <h4 id=measurement_1>Measurement:<a class=headerlink href=#measurement_1 title="Permanent link">&para;</a></h4> <p>Die Messwerte sind in der Regel numerisch (z.B. Temperatur, Luftfeuchtigkeit) und benötigen daher wenig Speicherplatz. <br></p> <table> <thead> <tr> <th>Datenfeld</th> <th>Typ</th> <th>Größe (Bytes)</th> <th>Beschreibung</th> </tr> </thead> <tbody> <tr> <td>timestamp</td> <td>Datetime</td> <td>8</td> <td>Timestamp</td> </tr> <tr> <td>value</td> <td>Float</td> <td>4</td> <td>Numerisch</td> </tr> <tr> <td>unit</td> <td>String</td> <td>2</td> <td>Einheit als Kurzstring (z.B. "C")</td> </tr> <tr> <td>sensor_type</td> <td>String</td> <td>2-4</td> <td>Sensortyp</td> </tr> <tr> <td>storage_id</td> <td>Integer</td> <td>2</td> <td>Lagerortreferenz</td> </tr> <tr> <td>Gesamt</td> <td>-</td> <td><strong>~18</strong></td> <td>Durchschnittlich pro Messung</td> </tr> </tbody> </table> <p><strong>Gesamtvolumen:</strong> 864.000 Messungen × ~ 18 Byte = <strong>~15,5 MB</strong></p> <h4 id=weitere-entitaten_1>Weitere Entitäten:<a class=headerlink href=#weitere-entitaten_1 title="Permanent link">&para;</a></h4> <p>Der Speicherbedarf der weiteren Entitäten ist ebenfalls gering, da sie nur wenige Attribute haben und in der Regel nicht sehr viele Instanzen existieren. <br></p> <ul> <li>Anschaulich lässt sich dies am Beispiel der User-Entität darstellen, die folgende Attribute hat:</li> </ul> <table> <thead> <tr> <th>Datenfeld</th> <th>Typ</th> <th>Größe (Bytes)</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>Integer</td> <td>4</td> </tr> <tr> <td>username</td> <td>String</td> <td>20</td> </tr> <tr> <td>password (hash)</td> <td>String</td> <td>64</td> </tr> <tr> <td>role_id</td> <td>Integer</td> <td>2</td> </tr> <tr> <td>description</td> <td>String</td> <td>50</td> </tr> <tr> <td>storage_id</td> <td>Integer[]</td> <td>8</td> </tr> <tr> <td>Gesamt</td> <td>-</td> <td><strong>~150</strong></td> </tr> </tbody> </table> <p><strong>Gesamtvolumen für 500 User:</strong> 500 User × ~ 150 Byte = <strong>~75 KB</strong></p> <h2 id=nichtfunktionale-anforderungen-datendomane>Nichtfunktionale Anforderungen &lt;=&gt; Datendomäne<a class=headerlink href=#nichtfunktionale-anforderungen-datendomane title="Permanent link">&para;</a></h2> <h3 id=einfluss-der-nicht-funktionalen-anforderungen-auf-die-datendomane><strong>Einfluss der nicht-funktionalen Anforderungen auf die Datendomäne</strong><a class=headerlink href=#einfluss-der-nicht-funktionalen-anforderungen-auf-die-datendomane title="Permanent link">&para;</a></h3> <p>Die definierten nicht-funktionalen Anforderungen beinflussen ggf. direkt die Auswahl der richtigen Datenbanktechnologie und werden dementsprechend im Folgenden auf die Datendomäne übertragen.</p> <h4 id=performance-und-schnelle-alarmierung><strong>Performance und schnelle Alarmierung</strong><a class=headerlink href=#performance-und-schnelle-alarmierung title="Permanent link">&para;</a></h4> <p>Die Anforderung, einen Alarm innerhalb von 90 Sekunden auszulösen, <em>nachdem</em> ein Grenzwert für über 30 Sekunden verletzt wurde, stellt eine hohe Anforderung an die Datenbank-Performance. Dies erfordert mehr als nur eine schnelle Einzelabfrage. Die Datenbank muss folgende Operationen sehr effizient unterstützen:</p> <ol> <li><strong>Schnelles Schreiben (Ingestion):</strong> Jeder neue <code>Measurement</code>-Datensatz muss mit minimaler Latenz gespeichert werden, damit die Alarmierungskette sofort starten kann.</li> <li><strong>Effiziente Zeitfenster-Abfragen:</strong> Um eine 30-sekündige Grenzwertverletzung zu erkennen, muss das System eine Abfrage wie "Gib mir alle Messwerte von <code>sensor_x</code> der letzten 30-40 Sekunden" sehr schnell ausführen können. Dies verlangt Indexierungsfähigkeiten, insbesondere auf den Feldern <code>timestamp</code> und <code>sensor_id</code>.</li> </ol> <h4 id=hohe-verfugbarkeit><strong>Hohe Verfügbarkeit</strong><a class=headerlink href=#hohe-verfugbarkeit title="Permanent link">&para;</a></h4> <p>Die geforderte Verfügbarkeit von 99% über einen Zeitraum von drei Tagen erlaubt eine maximale Ausfallzeit von ca. 43 Minuten.</p> <ul> <li><strong>Stabilität und Datenpersistenz:</strong> Die Datenbank muss ein robuster, stabiler Dienst sein, der Daten zuverlässig auf die Festplatte schreibt. Bei einem Neustart dürfen so keine Daten verloren gehen (was beispielsweise reine In-Memory-Datenbanken ausschließt). Basierend auf der Anforderung einer Verfügbarkeit von 99% muss die Technologie stabil innerhalb einer Docker-Umgebung laufen.</li> <li><strong>Unterstützung für Resilienz:</strong> Die Anforderung des automatischen Neustarts wird von der Infrastruktur (Docker Compose) umgesetzt. Die Datenbank muss diesen Prozess jedoch zuverlässig unterstützen, d.h. nach einem unerwarteten Herunterfahren schnell und konsistent wieder hochfahren.</li> </ul> <h4 id=sicherheit-authentifizierung-autorisierung><strong>Sicherheit (Authentifizierung &amp; Autorisierung)</strong><a class=headerlink href=#sicherheit-authentifizierung-autorisierung title="Permanent link">&para;</a></h4> <p>Diese Anforderung betrifft primär die Anwendungslogik, aber die Datenbank muss die sichere Implementierung unterstützen:</p> <ul> <li><strong>Sichere Datenspeicherung:</strong> Die Datenbank muss sensible Daten wie gehashte Passwörter in der <code>User</code>-Entität sicher speichern.</li> <li><strong>Unterstützung relationaler Integrität:</strong> Um die Autorisierung (wer darf auf welchen <code>Storage</code> zugreifen?) sicherzustellen, muss die Datenbank die Beziehungen zwischen <code>User</code>, <code>Role</code> und <code>Storage</code> zuverlässig abbilden können. Ein System, das diese Beziehungen durch <strong>Constraints</strong> und <strong>Fremdschlüssel</strong> auf Datenbankebene garantiert, ist hier also wichtig, da es das Risiko von Fehlern in der Anwendungslogik reduziert.</li> </ul> <h2 id=datenbankauswahl-kriterien>Datenbankauswahl - Kriterien<a class=headerlink href=#datenbankauswahl-kriterien title="Permanent link">&para;</a></h2> <p>Die Auswahl der Datenbanktechnologie erfolgt nun anhand folgender Kriterien:</p> <ul> <li><strong>Unterstützung des Datenmodells</strong>: Die Datenbank muss in der Lage sein, die definierten Entitäten und deren Beziehungen (<a href=./#datenmodellierung>vgl. Datenmodellierung</a>) effizient abzubilden. Beispielsweise gilt es die Grundlage für die Sicherheit des Systems zu schaffen (vgl. <a href=./#nicht-funktionale-anforderungen--datendomäne>Nichtfunktionale Anforderungen &lt;=&gt; Datendomäne</a>). <br> <br></li> <li><strong>Komplexität</strong>: Die Implementierung des Datenmodells sollte sich insbesondere den fachlichen <a href=content/about/mvp.md#rahmenbedingungen>Rahmenbedingungen</a> des Projekts anpassen. <br> Aufgrund der Projektlaufzeit von 2.5 Monaten und der Teamgröße von 4 Personen gilt es somit unnötige Komplexität zu vermeiden. <br></li> <li> <p><em>Anmerkung: Das berechnete <a href=./#datenvolumen>Datenvolumen</a> ist mit unter 1 MB pro Woche sehr gering. Daher sind Skalierungsmechanismen (wie z.B. horizontales Sharding) für dieses Projekt nicht relevant. Das Kriterium bewertet stattdessen, wie gut die Datenbanktechnologie mit diesem spezifischen, moderaten Datenvolumen umgeht, ohne unnötigen administrativen oder ressourcentechnischen Overhead zu erzeugen. <br></em></p> </li> <li> <p><strong>Performance</strong>: Die Leistungsfähigkeit der Datenbank ist entscheidend für die Realisierung des schnellen Alarmsystems (vgl. <a href=./#nicht-funktionale-anforderungen--datendomäne>Nichtfunktionale Anforderungen &lt;=&gt; Datendomäne</a>). Hierbei gilt es insbesondere die Messdaten, die den Großteil des <a href=./#datenvolumen>Datenvolumens</a> ausmachen, effizient zu verwalten. <br> <br></p> </li> <li> <p><strong>Betriebsstabilität</strong>: Die Datenbank sollte robust im Betrieb sein - entscheidend ist es, einen konsistenten Betrieb mit minimaler Ausfallzeit zu gewährleisten (vgl. <a href=./#nicht-funktionale-anforderungen--datendomäne>Nichtfunktionale Anforderungen &lt;=&gt; Datendomäne</a>). <br> <br></p> </li> <li><strong>Datenintegrität und Konsistenz</strong>: Dieses Kriterium bewertet die Fähigkeit der Datenbank, die Korrektheit und Widerspruchsfreiheit der Daten sicherzustellen. Weiter ist die Garantie wichtig, dass Daten nach dem Speichern nicht verloren gehen oder korrumpiert werden (Datenpersistenz). Dies ist insbesondere für die Verwaltung der Nutzer mit ihren Rechten wichtig. <br> <br></li> <li><strong>Abfragemöglichkeiten für Visualisierung</strong>: Die Fähigkeit der Abfragesprache, komplexere Aggregationen (z.B. Durchschnittswerte, Gruppierungen) und Verknüpfungen zu formulieren, die für die Erstellung eines Dashboards wichtig sind. Die Kompatibilität mit Standard-Visualisierungstools ist hier ebenfalls relevant.</li> </ul> <h2 id=sql-vs-nosql>SQL vs NoSQL<a class=headerlink href=#sql-vs-nosql title="Permanent link">&para;</a></h2> <p>Die folgende Tabelle evaluiert einen relationalen SQL-Ansatz und einen dokumentenorientierten NoSQL-Ansatz anhand der festgelegten Kriterien:</p> <p><em>Anmerkung: Für den Vergleich wird als NoSQL-Typ die dokumentorientierte Datenbank initial ausgewählt, da jeder Measurement-Datensatz eine in sich geschlossene Informationseinheit darstellt (Zeitstempel, Wert, Sensor-ID etc.), die sich nativ als ein JSON-ähnliches Dokument abbilden lässt. Dieser Ansatz ist als einziger NoSQL-Typ flexibel genug, um sowohl die zeitreihenbasierten Measurement-Daten als auch die eher strukturierten Entitäten wie User und Storage in separaten Collections zu verwalten.</em></p> <table> <thead> <tr> <th>Kriterium</th> <th>SQL-Ansatz (Relational)</th> <th>NoSQL-Ansatz (Dokumentenorientiert)</th> </tr> </thead> <tbody> <tr> <td>Unterstützung des Datenmodells</td> <td>Sehr gut. Das relationale Modell eignet sich sehr gut, um die strukturierten Beziehungen zwischen User, Role und Storage durch Foreign Keys abzubilden. Die Measurement-Daten passen in eine separate, nach Zeitstempel indizierte Tabelle.</td> <td>Okay. Sehr gut für die flexiblen Measurement-Daten. Die Abbildung der relationalen Benutzer- und Zugriffsdaten ist jedoch umständlich. Beziehungen müssen in der Anwendungslogik (über Referenzen oder eingebettete Dokumente) verwaltet werden, was die Komplexität erhöht.</td> </tr> <tr> <td>Komplexität</td> <td>Gering. Das Datenmodell lässt sich intuitiv auf Tabellen abbilden. Die Datenbank übernimmt die Logik der Beziehungsintegrität. Das moderate Datenvolumen erfordert keinen administrativen Mehraufwand.</td> <td>Mittel. Während das Speichern der IoT-Daten einfach ist, erfordert die konsistente Abbildung der Benutzer-Zugriffsrechte mehr Entwicklungsaufwand. Der größte Vorteil – die einfache Skalierung bei riesigen Datenmengen – ist hier nicht relevant und führt zu unnötigem konzeptionellen Overhead.</td> </tr> <tr> <td>Performance</td> <td>Sehr gut. Moderne SQL-Datenbanken können das moderate Datenvolumen mühelos verarbeiten. Schnelle Schreibvorgänge und effiziente Zeitfenster-Abfragen für die Alarmierung sind durch Standard-Indizes auf den Zeitstempel- und Sensor-Feldern ohne Probleme und performant realisierbar.</td> <td>Sehr gut. Hohe Schreibleistung ist eine Kernstärke der meisten NoSQL Datenbanken. Die Abfragegeschwindigkeit für die Alarmierung wäre ebenfalls sehr gut. Bei diesem Anwendungsfall mit der geringen Datenmenge ist ein Performancevorteil jedoch fraglich.</td> </tr> <tr> <td>Betriebsstabilität</td> <td>Sehr hoch. Etablierte SQL-Datenbanken wie PostgreSQL sind für ihre Robustheit und stabilen Betrieb bekannt. Sie unterstützen einen zuverlässigen Neustart nach Ausfällen und fügen sich nahtlos in Docker-Umgebungen ein.</td> <td>Sehr hoch. Moderne NoSQL-Datenbanken sind ebenfalls für den stabilen Dauerbetrieb ausgelegt und für ihre Resilienz in verteilten Systemen bekannt.</td> </tr> <tr> <td>Datenintegrität &amp; Konsistenz</td> <td>Sehr hoch (nativ). Durch ACID-Transaktionen und Constraints (UNIQUE, FOREIGN KEY) wird die Konsistenz der Daten auf Datenbankebene erzwungen. Dies ist besonders für die Verwaltung von Benutzerrechten und die Sicherheit des Systems ein entscheidender Vorteil.</td> <td>Mittel. Bietet standardmäßig schwächere Konsistenzmodelle (Eventual Consistency). Obwohl moderne Systeme auch ACID-Transaktionen unterstützen, liegt die Verantwortung für die Datenintegrität bei relationalen Verknüpfungen größtenteils beim Entwickler im Anwendungscode.</td> </tr> <tr> <td>Abfragemöglichkeiten für Visualisierung</td> <td>Sehr gut. Die standardisierte Abfragesprache SQL ist geeignet für komplexe Aggregationen (GROUP BY) und Verknüpfungen (JOIN), die für Dashboards wichtig sind (z.B. Anzeige von Lagerortnamen zu Messwerten).</td> <td>Gut. Proprietäre Abfragesprachen sind mächtig, aber weniger standardisiert. Das Verknüpfen von Daten aus unterschiedlichen Collections ist oft aufwendiger als ein SQL-JOIN.</td> </tr> </tbody> </table> <p>Der Vergleich zeigt, dass der SQL-Ansatz für das Projekt die bessere Wahl ist. Die Stärken des relationalen Modells in Bezug auf Datenintegrität, Konsistenz und die einfache Abbildung der Beziehungen zwischen den Entitäten sind entscheidend. Insgesamt lässt sich das Datenmodell so leichter (und schneller) umsetzen. Performance und Betriebsstabilität sind in beiden Fällen hoch, aber der SQL-Ansatz bietet eine klarere Struktur für die Verwaltung der Benutzerrechte und Zugriffe. <br> Weiter lässt sich die Performance, insbesondere hinsichtlich der Measurement-Daten, in der SQL-Datenbank durch Indizes auf beispielsweise den Zeitstempel manuell beziehungsweise durch Nutzung einer spezialisierten SQL-Datenbank (Timeseries) verbessern. <br> Auch die Abfragemöglichkeiten im Zuge der Visualisierung mittels eines Dashboards sind im SQL-Ansatz gegeben, da SQL eine standardisierte und mächtige Abfragesprache bietet, die komplexe Aggregationen und Verknüpfungen unterstützt. <br></p> <h2 id=datenbanktechnologie-postgresql-mit-timescaledb>Datenbanktechnologie - PostgreSQl mit TimescaleDB<a class=headerlink href=#datenbanktechnologie-postgresql-mit-timescaledb title="Permanent link">&para;</a></h2> <p>Um einerseits die einfachen, zeitabhängigen Messreihen effizient verwalten zu können und andererseits die "relationalen Metadaten" (User, Role, Storage) mit ihren Beziehungen abzubilden, wird die <strong>PostgreSQL</strong>-Datenbank ausgewählt. <br> Diese hat sich als eine der leistungsfähigsten Open-Source-Datenbanken etabliert und bietet neben dem klassichen relationalen Ansatz auch Unterstützung für zeitbasierte Daten durch die Erweiterung <strong>TimescaleDB</strong>. <br> TimescaleDB ist eine Erweiterung für PostgreSQL, die speziell für die Speicherung und Abfrage von Zeitreihendaten entwickelt wurde. Sie bietet Funktionen wie automatische Partitionierung (Chunking) und Indizierung, die die Performance bei zeitbasierten Abfragen erheblich verbessern [1]. <br> Für das Projekt bietet diese Kombination folgende Vorteile, die direkt auf die zuvor definierten Auswahlkriterien abzielen:</p> <ul> <li>Optimale Performance für die Alarmierung: Die zentrale Anforderung des schnellen Alarmsystems wird durch TimescaleDB ideal unterstützt. Die Measurement-Tabelle wird als sogenannte Hypertable konfiguriert. Dadurch werden die Messdaten im Hintergrund automatisch nach Zeit partitioniert, was Abfragen auf kurzen Zeitfenstern ("alle Werte der letzten 30 Sekunden") extrem performant macht.</li> <li>Hohe Datenintegrität bei geringer Komplexität: Während TimescaleDB die Zeitreihendaten optimiert, kümmert sich der PostgreSQL-Kern um die relationalen Daten. Die Beziehungen zwischen User, Role und Storage werden durch Foreign Keys und ACID-Transaktionen auf Datenbankebene abgesichert. Dies ermöglicht die Datenkonsistenz, reduziert den Entwicklungsaufwand im Backend und vermeidet Komplexität.</li> <li>Python-Entwickler-Unterstützung: PostgreSQL ist im Python-Ökosystem integriert und wird von Bibliotheken wie SQLAlchemy optimal unterstützt. Die Verwendung von standardisiertem SQL erleichtert zudem die Anbindung von Visualisierungs-Tools und die Formulierung komplexer Abfragen für das Analyse-Dashboard.</li> <li>Betriebsstabilität: Obwohl das aktuelle Datenvolumen gering ist, ist das System von Anfang an für ein potenzielles Wachstum der Sensordaten ausgelegt. Die Betriebsstabilität von PostgreSQL ermöglicht zudem die geforderte hohe Verfügbarkeit in einer Docker-Umgebung [2].</li> <li>Open-Source: PostgreSQL ist eine weit verbreitete Open-Source-Datenbank mit einer großen Community. Langfristige Unterstützung, regelmäßige Updates und eine Vielzahl von Ressourcen und Features für Entwickler werden so kostenlos ermöglicht.</li> </ul> <h3 id=timescaledb-unter-der-haube-1>TimescaleDB unter der Haube [1]<a class=headerlink href=#timescaledb-unter-der-haube-1 title="Permanent link">&para;</a></h3> <p>Die TimescaleDB-Erweiterung steigert die Effizienz bei der Verarbeitung von zeitabhängigen Messreihen in PostgreSQL durch einen optimierten Mechanismus: Die automatische Partitionierung von Daten in sogenannte <strong>Hypertables</strong>.</p> <p><em>Grundsätzlich gilt: Je länger die Laufzeit des Systems, desto mehr Messwerte werden erfasst und desto mehr lassen sich die Vorteile von TimescaleDB erkennen.</em></p> <h4 id=1-hypertables-chunks>1. Hypertables, Chunks:<a class=headerlink href=#1-hypertables-chunks title="Permanent link">&para;</a></h4> <ul> <li>Anstatt alle Messwerte in einer einzigen, riesigen Tabelle zu speichern, wandelt TimescaleDB die Tabelle in eine sogenannte Hypertable um. Diese Hypertable ist eine virtuelle Abstraktion, die im Hintergrund aus vielen kleineren, physischen Tabellen (= <strong>Chunks</strong>) besteht.</li> <li><strong>Automatische Partitionierung</strong>: TimescaleDB teilt die Daten automatisch nach einem Zeitintervall in diese Chunks auf. Beispielweise kann festlegt werden, dass für jede Woche ein neuer Chunk erstellt wird. Alle Messwerte, die in dieser Woche anfallen, werden ausschließlich in diesen einen Chunk geschrieben.</li> </ul> <h4 id=2-mogliche-effizienzgewinne>2. (Mögliche) Effizienzgewinne:<a class=headerlink href=#2-mogliche-effizienzgewinne title="Permanent link">&para;</a></h4> <ul> <li><strong>Schnellere Abfragen (Query Performance)</strong>: Wenn man eine Abfrage startet, die auf einen kurzen Zeitraum begrenzt ist (z.B. "Gib mir alle Temperaturwerte der letzten Minute"), muss PostgreSQL nicht die gesamte Tabelle durchsuchen. Stattdessen identifiziert TimescaleDB sofort, welcher Chunk (oder welche wenigen Chunks) die Daten für diesen Zeitraum enthält, und scannt nur diese sehr kleinen Tabellen.</li> <li><strong>Schnelleres Schreiben (Ingest Performance)</strong>: Neue Messwerte werden immer nur in den neuesten Chunk geschrieben. Da dieser Chunk relativ klein ist und oft vollständig im Arbeitsspeicher gehalten wird, bleibt der Schreibvorgang konstant schnell, selbst wenn das Gesamtvolumen der historischen Daten auf ssehr viele Einträge (z.B. Millionen) anwächst. Ohne TimescaleDB würden die Indizes einer einzigen großen Tabelle mit der Zeit fragmentieren und Schreibvorgänge verlangsamen.</li> <li><strong>Datenverwaltung</strong>:<ul> <li><strong>Löschen</strong>: Das Löschen alter Daten (z.B. "alle Messwerte älter als ein Jahr") wird effizienter, da durch die Chunks ganze Tabellen auf einmal mit (DROP TABLE) entfernt werden können, anstatt Zeile für Zeile zu löschen.</li> <li><strong>Komprimierung - Speicherbedarf</strong>: TimescaleDB bietet auch eine eingebaute Komprimierung für ältere Chunks, die den Speicherbedarf weiter reduziert.</li> <li><strong>Komprimierung - Abfragegeschwindigkeit</strong>: TimescaleDB kann auf die Daten im komprimierten Zustand wie in einem spaltenorientierten Format zugreifen. Anstatt eine ganze Zeile mit allen Datenfeldern (timestamp, value, unit etc.) lesen zu müssen (wie es bei klassicher seitenweiser Speicherung der Fall ist), kann die Datenbank gezielt nur die Spalten abrufen, die für die Abfrage benötigt werden – zum Beispiel nur den value.</li> </ul> </li> </ul> <h3 id=datenbank>Datenbank<a class=headerlink href=#datenbank title="Permanent link">&para;</a></h3> <p>Die modellierte Datenbank sieht wie folgt aus:</p> <p><img alt src=../../../images/data_eva/erd.svg></p> <p>Hierbei wurden die folgenden Konzepte wahrgenommen:</p> <ul> <li>Jeder Nutzer hat Zugriff auf mehrere Lagerorte und jeder Lagerort kann von mehreren Nutzern zugegriffen werden. Aus diesem Grund gibt es eine many-to-many Beziehung zwischen Nutzern und Lagerorten, bzw. zwischen der <code>User</code> und der <code>Storage</code> Tabelle. Der Zugriff auf ein Lagerort erfolgt durch den eindeutigen Namen des Lagerorts und des dazugehörigen Passworts.</li> <li>Unterschiedliche Nutzer sollen adequate Rechte auf diesen haben können. Beispielsweise soll es Administratoren und gewöhnliche Nutze geben. Daher existiert ein Feld <code>user_role</code> vom Typ <code>UserRole</code> in der Tabelle <code>UserStorageAccess</code>. Dieser Datentyp ist lediglich ein ENUM.</li> <li>Ein Lagerort soll mehrere Sensore haben, daher die many-to-one Beziehung zwischen den Tabellen <code>Sensor</code> und <code>Storage</code>. Zusätzlich hat ein Sensor Grenzwerte, zwischen denen Messungen liegen sollten, um Schäden in den Waren zu vermeiden, daher die Felder <code>allowed_min</code> und <code>allowed_max</code>.</li> <li>Jeder Sensor nimmt daten auf. Daher wurde eine Tabelle <code>Measurement</code> eingeführt, die eine many-to-one Beziehung zur Tabelle <code>Sensor</code> hat. Das Feld <code>unit</code> ist vom ENUM Typ <code>MeasurementUnit</code>, welches alle möglichen Einheiten beinhaltet (z.B. <code>CELSIUS</code> und <code>FAHRENHEIT</code> für die Temperatur, <code>PERCENT</code> für die Luftfeuchtigkeit usw.). Dieser Datentyp soll inkonsistenzen vermeiden, die es bei gewöhnlichem Text gibt (z.B. beziehen sich <code>Celsius</code> und <code>C</code> auf die selbe Einheit). Das Feld <code>created_at</code> bezoeht sich auf den genauen Zeitpunkt der Messung der Daten. Diese Tabelle soll eine Hypertable sein, um die Messungen möglichst effizient abrufen zu können.</li> <li>Messungen, die die Grenzwerte des Sensors überschreiten, lösen ein Alarm aus, daher die Tabelle <code>Alarm</code>. das Feld <code>severity</code> vom ENUM Typ <code>AlarmSeverity</code> beschreibt die Schwere des Alarms (<code>HIGH</code>, <code>MEDIUM</code>, <code>LOW</code>). Das Feld <code>message</code> ist eine vom System generierte Nachricht, die den Alarm beschreibt und dem Nutzer angezeigt wird.</li> </ul> <hr> <p>Quellen:</p> <ul> <li>[1] <a href=https://www.tigerdata.com/blog/postgresql-timescaledb-1000x-faster-queries-90-data-compression-and-much-more>PostgreSQL + TimescaleDB: 1,000x Faster Queries, 90 % Data Compression, and Much More</a></li> <li>[2] <a href=https://docs.tigerdata.com/self-hosted/latest/install/installation-docker/ >Install TimescaleDB from a Docker container</a></li> <li><a href=https://www.tigerdata.com/blog/storing-iot-data-why-you-should-use-postgresql>Storing IoT Data: 8 Reasons Why You Should Use PostgreSQL</a></li> <li><a href=https://www.prisma.io/dataguide/postgresql/benefits-of-postgresql#robust-feature-set>The benefits of PostgreSQL</a></li> <li><a href=https://www.ionos.com/digitalguide/server/know-how/postgresql/ >PostgreSQL: a closer look at the object-relational database management system</a></li> </ul> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script> <script src=../../../assets/javascripts/bundle.56ea9cef.min.js></script> </body> </html>